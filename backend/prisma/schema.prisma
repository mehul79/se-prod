generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ------------------------
// Enums
// ------------------------

enum Role {
  STUDENT
  TEACHER
}

enum AssessmentType {
  MCQ
  CODING
}

enum AttemptStatus {
  IN_PROGRESS
  SUBMITTED
  EVALUATED
  CANCELED
}


/// Users: students, teachers, admins
model User {
  id           String   @id @default(uuid())
  name         String?
  email        String   @unique
  passwordHash String?
  role         Role     @default(STUDENT)

  // student-only
  rollNumber   String?  @unique
  branchId     String?  
  branch       Branch?  @relation(fields: [branchId], references: [id])

  avatarUrl    String?
  cgpa         Float?
  isActive     Boolean  @default(true)

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // relations
  uploadedFiles        File[]
  createdAssessments   Assessment[] @relation("assessment_creator")
  assessmentAttempts   AssessmentAttempt[]
  createdAssignments   Assignment[]  @relation("assignment_creator")
  createdGroups Group[]   @relation("group_creator")
  submissions          AssignmentSubmission[]
  groups               GroupMember[]
  createdEvents        CalendarEvent[] @relation("event_creator")
  salaryRecords        TeacherSalary[]
  fees                 Fee[]
}

/// Branch / department (CSE, ECE...)
model Branch {
  id        String   @id @default(uuid())
  name      String
  code      String?  @unique

  users     User[]
  subjects  Subject[]
  labs      Lab[]
  calendarEventBranches CalendarEventBranch[]
}

/// Subject under a branch
model Subject {
  id        String   @id @default(uuid())
  name      String
  code      String?
  branchId  String?
  branch    Branch?  @relation(fields: [branchId], references: [id])

  folders   Folder[]
  files     File[]
  assessments Assessment[]
  assignments Assignment[]
  events CalendarEvent[]
}

/// Folder within a subject for study materials
model Folder {
  id        String   @id @default(uuid())
  name      String
  subjectId String
  subject   Subject  @relation(fields: [subjectId], references: [id])

  files     File[]
  createdAt DateTime @default(now())
}

/// File metadata only; binary stored by chosen provider (UploadThing / local / S3)
model File {
  id           String          @id @default(uuid())
  filename     String
  url          String
  mimeType     String?
  size         Int?
  externalId   String?

  subjectId    String?
  subject      Subject?        @relation(fields: [subjectId], references: [id])

  folderId     String?
  folder       Folder?         @relation(fields: [folderId], references: [id])

  uploadedById String?
  uploadedBy   User?           @relation(fields: [uploadedById], references: [id])

  uploadedAt   DateTime        @default(now())
  metadata     Json?

  submissionFiles AssignmentSubmissionFile[]
}

/// Assessments (MCQ / Coding)
model Assessment {
  id             String         @id @default(uuid())
  title          String
  description    String?
  type           AssessmentType
  subjectId      String?
  subject        Subject?     @relation(fields: [subjectId], references: [id])
  createdById    String?
  creator        User?        @relation("assessment_creator", fields: [createdById], references: [id])
  passcodeHash   String?
  durationMin    Int?
  startAt        DateTime?
  endAt          DateTime?
  maxMarks       Int?
  questionsJson  Json?
  attempts       AssessmentAttempt[]

  // ðŸ‘‡ OPTIONAL â€” linked CalendarEvent must enforce the constraint on the other side
  calendarEvent  CalendarEvent?

  createdAt      DateTime     @default(now())
}
/// Attempts by students for assessments
model AssessmentAttempt {
  id            String       @id @default(uuid())
  assessmentId  String
  assessment    Assessment   @relation(fields: [assessmentId], references: [id])

  studentId     String
  student       User         @relation(fields: [studentId], references: [id])

  startedAt     DateTime     @default(now())
  submittedAt   DateTime?
  score         Float?
  status        AttemptStatus @default(IN_PROGRESS)
  attemptData   Json?
  cameraOn      Boolean?
  micOn         Boolean?

  createdAt     DateTime     @default(now())

  @@index([assessmentId])
  @@index([studentId])
}

/// Assignments created by teachers
model Assignment {
  id           String    @id @default(uuid())
  title        String
  description  String?

  subjectId    String?
  subject      Subject?  @relation(fields: [subjectId], references: [id])

  createdById  String?
  creator      User?     @relation("assignment_creator", fields: [createdById], references: [id])

  dueAt        DateTime?
  groupAllowed Boolean   @default(false)

  createdAt    DateTime  @default(now())
  submissions  AssignmentSubmission[]
}

/// Student groups
model Group {
  id         String         @id @default(uuid())
  name       String?
  createdById String?
  createdBy   User? @relation("group_creator", fields: [createdById], references: [id])
  createdAt  DateTime       @default(now())

  members    GroupMember[]
  submissions AssignmentSubmission[]
}

model GroupMember {
  id       String  @id @default(uuid())
  groupId  String
  group    Group   @relation(fields: [groupId], references: [id])

  userId   String
  user     User    @relation(fields: [userId], references: [id])

  role     String?
  joinedAt DateTime @default(now())

  @@unique([groupId, userId])
}

/// Assignment submissions
model AssignmentSubmission {
  id            String   @id @default(uuid())
  assignmentId  String
  assignment    Assignment @relation(fields: [assignmentId], references: [id])

  submittedById String?
  submittedBy   User?    @relation(fields: [submittedById], references: [id])

  groupId       String?
  group         Group?   @relation(fields: [groupId], references: [id])

  submittedAt   DateTime @default(now())
  metadata      Json?
  grade         Float?
  feedback      String?

  files         AssignmentSubmissionFile[]
}

model AssignmentSubmissionFile {
  id           String   @id @default(uuid())
  submissionId String
  submission   AssignmentSubmission @relation(fields: [submissionId], references: [id])

  fileId       String
  file         File     @relation(fields: [fileId], references: [id])
}

/// Labs
model Lab {
  id        String   @id @default(uuid())
  name      String
  code      String?
  location  String?
  capacity  Int?
  branchId  String?
  branch    Branch?  @relation(fields: [branchId], references: [id])

  events    CalendarEvent[]
}

/// Calendar events
model CalendarEvent {
  id           String   @id @default(uuid())
  title        String
  description  String?

  subjectId    String?
  subject      Subject? @relation(fields: [subjectId], references: [id])

  // ðŸ‘‡ REQUIRED â€” this is the side with fields + references
  assessmentId String   @unique
  assessment   Assessment @relation(fields: [assessmentId], references: [id])

  startAt      DateTime
  endAt        DateTime

  createdById  String?
  creator      User? @relation("event_creator", fields: [createdById], references: [id])

  labId        String?
  lab          Lab? @relation(fields: [labId], references: [id])

  branches     CalendarEventBranch[]
  createdAt    DateTime @default(now())
}

model CalendarEventBranch {
  id              String         @id @default(uuid())
  calendarEventId String
  calendarEvent   CalendarEvent  @relation(fields: [calendarEventId], references: [id])

  branchId        String
  branch          Branch         @relation(fields: [branchId], references: [id])

  @@unique([calendarEventId, branchId])
}

/// Teacher salary
model TeacherSalary {
  id         String   @id @default(uuid())
  teacherId  String
  teacher    User     @relation(fields: [teacherId], references: [id])

  base       Float
  allowances Float?
  deductions Float?
  periodStart DateTime
  periodEnd   DateTime
  paid       Boolean  @default(false)
  createdAt  DateTime @default(now())
}

/// School fee
model Fee {
  id        String   @id @default(uuid())
  studentId String
  student   User     @relation(fields: [studentId], references: [id])
  amount    Float
  dueDate   DateTime?
  paid      Boolean  @default(false)
  createdAt DateTime @default(now())
}
